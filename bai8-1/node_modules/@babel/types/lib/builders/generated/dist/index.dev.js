"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayExpression = arrayExpression;
exports.assignmentExpression = assignmentExpression;
exports.binaryExpression = binaryExpression;
exports.interpreterDirective = interpreterDirective;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.blockStatement = blockStatement;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.labeledStatement = labeledStatement;
exports.stringLiteral = stringLiteral;
exports.numericLiteral = numericLiteral;
exports.nullLiteral = nullLiteral;
exports.booleanLiteral = booleanLiteral;
exports.regExpLiteral = regExpLiteral;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.newExpression = newExpression;
exports.program = program;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectProperty = objectProperty;
exports.restElement = restElement;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.thisExpression = thisExpression;
exports.throwStatement = throwStatement;
exports.tryStatement = tryStatement;
exports.unaryExpression = unaryExpression;
exports.updateExpression = updateExpression;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.assignmentPattern = assignmentPattern;
exports.arrayPattern = arrayPattern;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.classBody = classBody;
exports.classExpression = classExpression;
exports.classDeclaration = classDeclaration;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportSpecifier = exportSpecifier;
exports.forOfStatement = forOfStatement;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.metaProperty = metaProperty;
exports.classMethod = classMethod;
exports.objectPattern = objectPattern;
exports.spreadElement = spreadElement;
exports["super"] = _super;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.yieldExpression = yieldExpression;
exports.awaitExpression = awaitExpression;
exports["import"] = _import;
exports.bigIntLiteral = bigIntLiteral;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.optionalMemberExpression = optionalMemberExpression;
exports.optionalCallExpression = optionalCallExpression;
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.classImplements = classImplements;
exports.declareClass = declareClass;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareTypeAlias = declareTypeAlias;
exports.declareOpaqueType = declareOpaqueType;
exports.declareVariable = declareVariable;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declaredPredicate = declaredPredicate;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.inferredPredicate = inferredPredicate;
exports.interfaceExtends = interfaceExtends;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.enumDeclaration = enumDeclaration;
exports.enumBooleanBody = enumBooleanBody;
exports.enumNumberBody = enumNumberBody;
exports.enumStringBody = enumStringBody;
exports.enumSymbolBody = enumSymbolBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumNumberMember = enumNumberMember;
exports.enumStringMember = enumStringMember;
exports.enumDefaultedMember = enumDefaultedMember;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXText = exports.jsxText = jsxText;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.noop = noop;
exports.placeholder = placeholder;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.argumentPlaceholder = argumentPlaceholder;
exports.bindExpression = bindExpression;
exports.classProperty = classProperty;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.classPrivateProperty = classPrivateProperty;
exports.classPrivateMethod = classPrivateMethod;
exports.importAttribute = importAttribute;
exports.decorator = decorator;
exports.doExpression = doExpression;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.privateName = privateName;
exports.recordExpression = recordExpression;
exports.tupleExpression = tupleExpression;
exports.decimalLiteral = decimalLiteral;
exports.staticBlock = staticBlock;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.numberLiteral = NumberLiteral;
exports.regexLiteral = RegexLiteral;
exports.restProperty = RestProperty;
exports.spreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(require("../builder"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function arrayExpression(elements) {
  return (0, _builder["default"]).apply(void 0, ["ArrayExpression"].concat(Array.prototype.slice.call(arguments)));
}

function assignmentExpression(operator, left, right) {
  return (0, _builder["default"]).apply(void 0, ["AssignmentExpression"].concat(Array.prototype.slice.call(arguments)));
}

function binaryExpression(operator, left, right) {
  return (0, _builder["default"]).apply(void 0, ["BinaryExpression"].concat(Array.prototype.slice.call(arguments)));
}

function interpreterDirective(value) {
  return (0, _builder["default"]).apply(void 0, ["InterpreterDirective"].concat(Array.prototype.slice.call(arguments)));
}

function directive(value) {
  return (0, _builder["default"]).apply(void 0, ["Directive"].concat(Array.prototype.slice.call(arguments)));
}

function directiveLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["DirectiveLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function blockStatement(body, directives) {
  return (0, _builder["default"]).apply(void 0, ["BlockStatement"].concat(Array.prototype.slice.call(arguments)));
}

function breakStatement(label) {
  return (0, _builder["default"]).apply(void 0, ["BreakStatement"].concat(Array.prototype.slice.call(arguments)));
}

function callExpression(callee, _arguments) {
  return (0, _builder["default"]).apply(void 0, ["CallExpression"].concat(Array.prototype.slice.call(arguments)));
}

function catchClause(param, body) {
  return (0, _builder["default"]).apply(void 0, ["CatchClause"].concat(Array.prototype.slice.call(arguments)));
}

function conditionalExpression(test, consequent, alternate) {
  return (0, _builder["default"]).apply(void 0, ["ConditionalExpression"].concat(Array.prototype.slice.call(arguments)));
}

function continueStatement(label) {
  return (0, _builder["default"]).apply(void 0, ["ContinueStatement"].concat(Array.prototype.slice.call(arguments)));
}

function debuggerStatement() {
  return (0, _builder["default"]).apply(void 0, ["DebuggerStatement"].concat(Array.prototype.slice.call(arguments)));
}

function doWhileStatement(test, body) {
  return (0, _builder["default"]).apply(void 0, ["DoWhileStatement"].concat(Array.prototype.slice.call(arguments)));
}

function emptyStatement() {
  return (0, _builder["default"]).apply(void 0, ["EmptyStatement"].concat(Array.prototype.slice.call(arguments)));
}

function expressionStatement(expression) {
  return (0, _builder["default"]).apply(void 0, ["ExpressionStatement"].concat(Array.prototype.slice.call(arguments)));
}

function file(program, comments, tokens) {
  return (0, _builder["default"]).apply(void 0, ["File"].concat(Array.prototype.slice.call(arguments)));
}

function forInStatement(left, right, body) {
  return (0, _builder["default"]).apply(void 0, ["ForInStatement"].concat(Array.prototype.slice.call(arguments)));
}

function forStatement(init, test, update, body) {
  return (0, _builder["default"]).apply(void 0, ["ForStatement"].concat(Array.prototype.slice.call(arguments)));
}

function functionDeclaration(id, params, body, generator, async) {
  return (0, _builder["default"]).apply(void 0, ["FunctionDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function functionExpression(id, params, body, generator, async) {
  return (0, _builder["default"]).apply(void 0, ["FunctionExpression"].concat(Array.prototype.slice.call(arguments)));
}

function identifier(name) {
  return (0, _builder["default"]).apply(void 0, ["Identifier"].concat(Array.prototype.slice.call(arguments)));
}

function ifStatement(test, consequent, alternate) {
  return (0, _builder["default"]).apply(void 0, ["IfStatement"].concat(Array.prototype.slice.call(arguments)));
}

function labeledStatement(label, body) {
  return (0, _builder["default"]).apply(void 0, ["LabeledStatement"].concat(Array.prototype.slice.call(arguments)));
}

function stringLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["StringLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function numericLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["NumericLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function nullLiteral() {
  return (0, _builder["default"]).apply(void 0, ["NullLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function booleanLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["BooleanLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function regExpLiteral(pattern, flags) {
  return (0, _builder["default"]).apply(void 0, ["RegExpLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function logicalExpression(operator, left, right) {
  return (0, _builder["default"]).apply(void 0, ["LogicalExpression"].concat(Array.prototype.slice.call(arguments)));
}

function memberExpression(object, property, computed, optional) {
  return (0, _builder["default"]).apply(void 0, ["MemberExpression"].concat(Array.prototype.slice.call(arguments)));
}

function newExpression(callee, _arguments) {
  return (0, _builder["default"]).apply(void 0, ["NewExpression"].concat(Array.prototype.slice.call(arguments)));
}

function program(body, directives, sourceType, interpreter) {
  return (0, _builder["default"]).apply(void 0, ["Program"].concat(Array.prototype.slice.call(arguments)));
}

function objectExpression(properties) {
  return (0, _builder["default"]).apply(void 0, ["ObjectExpression"].concat(Array.prototype.slice.call(arguments)));
}

function objectMethod(kind, key, params, body, computed, generator, async) {
  return (0, _builder["default"]).apply(void 0, ["ObjectMethod"].concat(Array.prototype.slice.call(arguments)));
}

function objectProperty(key, value, computed, shorthand, decorators) {
  return (0, _builder["default"]).apply(void 0, ["ObjectProperty"].concat(Array.prototype.slice.call(arguments)));
}

function restElement(argument) {
  return (0, _builder["default"]).apply(void 0, ["RestElement"].concat(Array.prototype.slice.call(arguments)));
}

function returnStatement(argument) {
  return (0, _builder["default"]).apply(void 0, ["ReturnStatement"].concat(Array.prototype.slice.call(arguments)));
}

function sequenceExpression(expressions) {
  return (0, _builder["default"]).apply(void 0, ["SequenceExpression"].concat(Array.prototype.slice.call(arguments)));
}

function parenthesizedExpression(expression) {
  return (0, _builder["default"]).apply(void 0, ["ParenthesizedExpression"].concat(Array.prototype.slice.call(arguments)));
}

function switchCase(test, consequent) {
  return (0, _builder["default"]).apply(void 0, ["SwitchCase"].concat(Array.prototype.slice.call(arguments)));
}

function switchStatement(discriminant, cases) {
  return (0, _builder["default"]).apply(void 0, ["SwitchStatement"].concat(Array.prototype.slice.call(arguments)));
}

function thisExpression() {
  return (0, _builder["default"]).apply(void 0, ["ThisExpression"].concat(Array.prototype.slice.call(arguments)));
}

function throwStatement(argument) {
  return (0, _builder["default"]).apply(void 0, ["ThrowStatement"].concat(Array.prototype.slice.call(arguments)));
}

function tryStatement(block, handler, finalizer) {
  return (0, _builder["default"]).apply(void 0, ["TryStatement"].concat(Array.prototype.slice.call(arguments)));
}

function unaryExpression(operator, argument, prefix) {
  return (0, _builder["default"]).apply(void 0, ["UnaryExpression"].concat(Array.prototype.slice.call(arguments)));
}

function updateExpression(operator, argument, prefix) {
  return (0, _builder["default"]).apply(void 0, ["UpdateExpression"].concat(Array.prototype.slice.call(arguments)));
}

function variableDeclaration(kind, declarations) {
  return (0, _builder["default"]).apply(void 0, ["VariableDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function variableDeclarator(id, init) {
  return (0, _builder["default"]).apply(void 0, ["VariableDeclarator"].concat(Array.prototype.slice.call(arguments)));
}

function whileStatement(test, body) {
  return (0, _builder["default"]).apply(void 0, ["WhileStatement"].concat(Array.prototype.slice.call(arguments)));
}

function withStatement(object, body) {
  return (0, _builder["default"]).apply(void 0, ["WithStatement"].concat(Array.prototype.slice.call(arguments)));
}

function assignmentPattern(left, right) {
  return (0, _builder["default"]).apply(void 0, ["AssignmentPattern"].concat(Array.prototype.slice.call(arguments)));
}

function arrayPattern(elements) {
  return (0, _builder["default"]).apply(void 0, ["ArrayPattern"].concat(Array.prototype.slice.call(arguments)));
}

function arrowFunctionExpression(params, body, async) {
  return (0, _builder["default"]).apply(void 0, ["ArrowFunctionExpression"].concat(Array.prototype.slice.call(arguments)));
}

function classBody(body) {
  return (0, _builder["default"]).apply(void 0, ["ClassBody"].concat(Array.prototype.slice.call(arguments)));
}

function classExpression(id, superClass, body, decorators) {
  return (0, _builder["default"]).apply(void 0, ["ClassExpression"].concat(Array.prototype.slice.call(arguments)));
}

function classDeclaration(id, superClass, body, decorators) {
  return (0, _builder["default"]).apply(void 0, ["ClassDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function exportAllDeclaration(source) {
  return (0, _builder["default"]).apply(void 0, ["ExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function exportDefaultDeclaration(declaration) {
  return (0, _builder["default"]).apply(void 0, ["ExportDefaultDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function exportNamedDeclaration(declaration, specifiers, source) {
  return (0, _builder["default"]).apply(void 0, ["ExportNamedDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function exportSpecifier(local, exported) {
  return (0, _builder["default"]).apply(void 0, ["ExportSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function forOfStatement(left, right, body, _await) {
  return (0, _builder["default"]).apply(void 0, ["ForOfStatement"].concat(Array.prototype.slice.call(arguments)));
}

function importDeclaration(specifiers, source) {
  return (0, _builder["default"]).apply(void 0, ["ImportDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function importDefaultSpecifier(local) {
  return (0, _builder["default"]).apply(void 0, ["ImportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function importNamespaceSpecifier(local) {
  return (0, _builder["default"]).apply(void 0, ["ImportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function importSpecifier(local, imported) {
  return (0, _builder["default"]).apply(void 0, ["ImportSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function metaProperty(meta, property) {
  return (0, _builder["default"]).apply(void 0, ["MetaProperty"].concat(Array.prototype.slice.call(arguments)));
}

function classMethod(kind, key, params, body, computed, _static, generator, async) {
  return (0, _builder["default"]).apply(void 0, ["ClassMethod"].concat(Array.prototype.slice.call(arguments)));
}

function objectPattern(properties) {
  return (0, _builder["default"]).apply(void 0, ["ObjectPattern"].concat(Array.prototype.slice.call(arguments)));
}

function spreadElement(argument) {
  return (0, _builder["default"]).apply(void 0, ["SpreadElement"].concat(Array.prototype.slice.call(arguments)));
}

function _super() {
  return (0, _builder["default"]).apply(void 0, ["Super"].concat(Array.prototype.slice.call(arguments)));
}

function taggedTemplateExpression(tag, quasi) {
  return (0, _builder["default"]).apply(void 0, ["TaggedTemplateExpression"].concat(Array.prototype.slice.call(arguments)));
}

function templateElement(value, tail) {
  return (0, _builder["default"]).apply(void 0, ["TemplateElement"].concat(Array.prototype.slice.call(arguments)));
}

function templateLiteral(quasis, expressions) {
  return (0, _builder["default"]).apply(void 0, ["TemplateLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function yieldExpression(argument, delegate) {
  return (0, _builder["default"]).apply(void 0, ["YieldExpression"].concat(Array.prototype.slice.call(arguments)));
}

function awaitExpression(argument) {
  return (0, _builder["default"]).apply(void 0, ["AwaitExpression"].concat(Array.prototype.slice.call(arguments)));
}

function _import() {
  return (0, _builder["default"]).apply(void 0, ["Import"].concat(Array.prototype.slice.call(arguments)));
}

function bigIntLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["BigIntLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function exportNamespaceSpecifier(exported) {
  return (0, _builder["default"]).apply(void 0, ["ExportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function optionalMemberExpression(object, property, computed, optional) {
  return (0, _builder["default"]).apply(void 0, ["OptionalMemberExpression"].concat(Array.prototype.slice.call(arguments)));
}

function optionalCallExpression(callee, _arguments, optional) {
  return (0, _builder["default"]).apply(void 0, ["OptionalCallExpression"].concat(Array.prototype.slice.call(arguments)));
}

function anyTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["AnyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function arrayTypeAnnotation(elementType) {
  return (0, _builder["default"]).apply(void 0, ["ArrayTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function booleanTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["BooleanTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function booleanLiteralTypeAnnotation(value) {
  return (0, _builder["default"]).apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function nullLiteralTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["NullLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function classImplements(id, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["ClassImplements"].concat(Array.prototype.slice.call(arguments)));
}

function declareClass(id, typeParameters, _extends, body) {
  return (0, _builder["default"]).apply(void 0, ["DeclareClass"].concat(Array.prototype.slice.call(arguments)));
}

function declareFunction(id) {
  return (0, _builder["default"]).apply(void 0, ["DeclareFunction"].concat(Array.prototype.slice.call(arguments)));
}

function declareInterface(id, typeParameters, _extends, body) {
  return (0, _builder["default"]).apply(void 0, ["DeclareInterface"].concat(Array.prototype.slice.call(arguments)));
}

function declareModule(id, body, kind) {
  return (0, _builder["default"]).apply(void 0, ["DeclareModule"].concat(Array.prototype.slice.call(arguments)));
}

function declareModuleExports(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["DeclareModuleExports"].concat(Array.prototype.slice.call(arguments)));
}

function declareTypeAlias(id, typeParameters, right) {
  return (0, _builder["default"]).apply(void 0, ["DeclareTypeAlias"].concat(Array.prototype.slice.call(arguments)));
}

function declareOpaqueType(id, typeParameters, supertype) {
  return (0, _builder["default"]).apply(void 0, ["DeclareOpaqueType"].concat(Array.prototype.slice.call(arguments)));
}

function declareVariable(id) {
  return (0, _builder["default"]).apply(void 0, ["DeclareVariable"].concat(Array.prototype.slice.call(arguments)));
}

function declareExportDeclaration(declaration, specifiers, source) {
  return (0, _builder["default"]).apply(void 0, ["DeclareExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function declareExportAllDeclaration(source) {
  return (0, _builder["default"]).apply(void 0, ["DeclareExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function declaredPredicate(value) {
  return (0, _builder["default"]).apply(void 0, ["DeclaredPredicate"].concat(Array.prototype.slice.call(arguments)));
}

function existsTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["ExistsTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function functionTypeAnnotation(typeParameters, params, rest, returnType) {
  return (0, _builder["default"]).apply(void 0, ["FunctionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function functionTypeParam(name, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["FunctionTypeParam"].concat(Array.prototype.slice.call(arguments)));
}

function genericTypeAnnotation(id, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["GenericTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function inferredPredicate() {
  return (0, _builder["default"]).apply(void 0, ["InferredPredicate"].concat(Array.prototype.slice.call(arguments)));
}

function interfaceExtends(id, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["InterfaceExtends"].concat(Array.prototype.slice.call(arguments)));
}

function interfaceDeclaration(id, typeParameters, _extends, body) {
  return (0, _builder["default"]).apply(void 0, ["InterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function interfaceTypeAnnotation(_extends, body) {
  return (0, _builder["default"]).apply(void 0, ["InterfaceTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function intersectionTypeAnnotation(types) {
  return (0, _builder["default"]).apply(void 0, ["IntersectionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function mixedTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["MixedTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function emptyTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["EmptyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function nullableTypeAnnotation(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["NullableTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function numberLiteralTypeAnnotation(value) {
  return (0, _builder["default"]).apply(void 0, ["NumberLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function numberTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["NumberTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeInternalSlot(id, value, optional, _static, method) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeInternalSlot"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeCallProperty(value) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeCallProperty"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeIndexer(id, key, value, variance) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeIndexer"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeProperty(key, value, variance) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeProperty"].concat(Array.prototype.slice.call(arguments)));
}

function objectTypeSpreadProperty(argument) {
  return (0, _builder["default"]).apply(void 0, ["ObjectTypeSpreadProperty"].concat(Array.prototype.slice.call(arguments)));
}

function opaqueType(id, typeParameters, supertype, impltype) {
  return (0, _builder["default"]).apply(void 0, ["OpaqueType"].concat(Array.prototype.slice.call(arguments)));
}

function qualifiedTypeIdentifier(id, qualification) {
  return (0, _builder["default"]).apply(void 0, ["QualifiedTypeIdentifier"].concat(Array.prototype.slice.call(arguments)));
}

function stringLiteralTypeAnnotation(value) {
  return (0, _builder["default"]).apply(void 0, ["StringLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function stringTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["StringTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function symbolTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["SymbolTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function thisTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["ThisTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function tupleTypeAnnotation(types) {
  return (0, _builder["default"]).apply(void 0, ["TupleTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function typeofTypeAnnotation(argument) {
  return (0, _builder["default"]).apply(void 0, ["TypeofTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function typeAlias(id, typeParameters, right) {
  return (0, _builder["default"]).apply(void 0, ["TypeAlias"].concat(Array.prototype.slice.call(arguments)));
}

function typeAnnotation(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function typeCastExpression(expression, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TypeCastExpression"].concat(Array.prototype.slice.call(arguments)));
}

function typeParameter(bound, _default, variance) {
  return (0, _builder["default"]).apply(void 0, ["TypeParameter"].concat(Array.prototype.slice.call(arguments)));
}

function typeParameterDeclaration(params) {
  return (0, _builder["default"]).apply(void 0, ["TypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function typeParameterInstantiation(params) {
  return (0, _builder["default"]).apply(void 0, ["TypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
}

function unionTypeAnnotation(types) {
  return (0, _builder["default"]).apply(void 0, ["UnionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function variance(kind) {
  return (0, _builder["default"]).apply(void 0, ["Variance"].concat(Array.prototype.slice.call(arguments)));
}

function voidTypeAnnotation() {
  return (0, _builder["default"]).apply(void 0, ["VoidTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function enumDeclaration(id, body) {
  return (0, _builder["default"]).apply(void 0, ["EnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function enumBooleanBody(members) {
  return (0, _builder["default"]).apply(void 0, ["EnumBooleanBody"].concat(Array.prototype.slice.call(arguments)));
}

function enumNumberBody(members) {
  return (0, _builder["default"]).apply(void 0, ["EnumNumberBody"].concat(Array.prototype.slice.call(arguments)));
}

function enumStringBody(members) {
  return (0, _builder["default"]).apply(void 0, ["EnumStringBody"].concat(Array.prototype.slice.call(arguments)));
}

function enumSymbolBody(members) {
  return (0, _builder["default"]).apply(void 0, ["EnumSymbolBody"].concat(Array.prototype.slice.call(arguments)));
}

function enumBooleanMember(id) {
  return (0, _builder["default"]).apply(void 0, ["EnumBooleanMember"].concat(Array.prototype.slice.call(arguments)));
}

function enumNumberMember(id, init) {
  return (0, _builder["default"]).apply(void 0, ["EnumNumberMember"].concat(Array.prototype.slice.call(arguments)));
}

function enumStringMember(id, init) {
  return (0, _builder["default"]).apply(void 0, ["EnumStringMember"].concat(Array.prototype.slice.call(arguments)));
}

function enumDefaultedMember(id) {
  return (0, _builder["default"]).apply(void 0, ["EnumDefaultedMember"].concat(Array.prototype.slice.call(arguments)));
}

function jsxAttribute(name, value) {
  return (0, _builder["default"]).apply(void 0, ["JSXAttribute"].concat(Array.prototype.slice.call(arguments)));
}

function jsxClosingElement(name) {
  return (0, _builder["default"]).apply(void 0, ["JSXClosingElement"].concat(Array.prototype.slice.call(arguments)));
}

function jsxElement(openingElement, closingElement, children, selfClosing) {
  return (0, _builder["default"]).apply(void 0, ["JSXElement"].concat(Array.prototype.slice.call(arguments)));
}

function jsxEmptyExpression() {
  return (0, _builder["default"]).apply(void 0, ["JSXEmptyExpression"].concat(Array.prototype.slice.call(arguments)));
}

function jsxExpressionContainer(expression) {
  return (0, _builder["default"]).apply(void 0, ["JSXExpressionContainer"].concat(Array.prototype.slice.call(arguments)));
}

function jsxSpreadChild(expression) {
  return (0, _builder["default"]).apply(void 0, ["JSXSpreadChild"].concat(Array.prototype.slice.call(arguments)));
}

function jsxIdentifier(name) {
  return (0, _builder["default"]).apply(void 0, ["JSXIdentifier"].concat(Array.prototype.slice.call(arguments)));
}

function jsxMemberExpression(object, property) {
  return (0, _builder["default"]).apply(void 0, ["JSXMemberExpression"].concat(Array.prototype.slice.call(arguments)));
}

function jsxNamespacedName(namespace, name) {
  return (0, _builder["default"]).apply(void 0, ["JSXNamespacedName"].concat(Array.prototype.slice.call(arguments)));
}

function jsxOpeningElement(name, attributes, selfClosing) {
  return (0, _builder["default"]).apply(void 0, ["JSXOpeningElement"].concat(Array.prototype.slice.call(arguments)));
}

function jsxSpreadAttribute(argument) {
  return (0, _builder["default"]).apply(void 0, ["JSXSpreadAttribute"].concat(Array.prototype.slice.call(arguments)));
}

function jsxText(value) {
  return (0, _builder["default"]).apply(void 0, ["JSXText"].concat(Array.prototype.slice.call(arguments)));
}

function jsxFragment(openingFragment, closingFragment, children) {
  return (0, _builder["default"]).apply(void 0, ["JSXFragment"].concat(Array.prototype.slice.call(arguments)));
}

function jsxOpeningFragment() {
  return (0, _builder["default"]).apply(void 0, ["JSXOpeningFragment"].concat(Array.prototype.slice.call(arguments)));
}

function jsxClosingFragment() {
  return (0, _builder["default"]).apply(void 0, ["JSXClosingFragment"].concat(Array.prototype.slice.call(arguments)));
}

function noop() {
  return (0, _builder["default"]).apply(void 0, ["Noop"].concat(Array.prototype.slice.call(arguments)));
}

function placeholder(expectedNode, name) {
  return (0, _builder["default"]).apply(void 0, ["Placeholder"].concat(Array.prototype.slice.call(arguments)));
}

function v8IntrinsicIdentifier(name) {
  return (0, _builder["default"]).apply(void 0, ["V8IntrinsicIdentifier"].concat(Array.prototype.slice.call(arguments)));
}

function argumentPlaceholder() {
  return (0, _builder["default"]).apply(void 0, ["ArgumentPlaceholder"].concat(Array.prototype.slice.call(arguments)));
}

function bindExpression(object, callee) {
  return (0, _builder["default"]).apply(void 0, ["BindExpression"].concat(Array.prototype.slice.call(arguments)));
}

function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
  return (0, _builder["default"]).apply(void 0, ["ClassProperty"].concat(Array.prototype.slice.call(arguments)));
}

function pipelineTopicExpression(expression) {
  return (0, _builder["default"]).apply(void 0, ["PipelineTopicExpression"].concat(Array.prototype.slice.call(arguments)));
}

function pipelineBareFunction(callee) {
  return (0, _builder["default"]).apply(void 0, ["PipelineBareFunction"].concat(Array.prototype.slice.call(arguments)));
}

function pipelinePrimaryTopicReference() {
  return (0, _builder["default"]).apply(void 0, ["PipelinePrimaryTopicReference"].concat(Array.prototype.slice.call(arguments)));
}

function classPrivateProperty(key, value, decorators, _static) {
  return (0, _builder["default"]).apply(void 0, ["ClassPrivateProperty"].concat(Array.prototype.slice.call(arguments)));
}

function classPrivateMethod(kind, key, params, body, _static) {
  return (0, _builder["default"]).apply(void 0, ["ClassPrivateMethod"].concat(Array.prototype.slice.call(arguments)));
}

function importAttribute(key, value) {
  return (0, _builder["default"]).apply(void 0, ["ImportAttribute"].concat(Array.prototype.slice.call(arguments)));
}

function decorator(expression) {
  return (0, _builder["default"]).apply(void 0, ["Decorator"].concat(Array.prototype.slice.call(arguments)));
}

function doExpression(body) {
  return (0, _builder["default"]).apply(void 0, ["DoExpression"].concat(Array.prototype.slice.call(arguments)));
}

function exportDefaultSpecifier(exported) {
  return (0, _builder["default"]).apply(void 0, ["ExportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
}

function privateName(id) {
  return (0, _builder["default"]).apply(void 0, ["PrivateName"].concat(Array.prototype.slice.call(arguments)));
}

function recordExpression(properties) {
  return (0, _builder["default"]).apply(void 0, ["RecordExpression"].concat(Array.prototype.slice.call(arguments)));
}

function tupleExpression(elements) {
  return (0, _builder["default"]).apply(void 0, ["TupleExpression"].concat(Array.prototype.slice.call(arguments)));
}

function decimalLiteral(value) {
  return (0, _builder["default"]).apply(void 0, ["DecimalLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function staticBlock(body) {
  return (0, _builder["default"]).apply(void 0, ["StaticBlock"].concat(Array.prototype.slice.call(arguments)));
}

function tsParameterProperty(parameter) {
  return (0, _builder["default"]).apply(void 0, ["TSParameterProperty"].concat(Array.prototype.slice.call(arguments)));
}

function tsDeclareFunction(id, typeParameters, params, returnType) {
  return (0, _builder["default"]).apply(void 0, ["TSDeclareFunction"].concat(Array.prototype.slice.call(arguments)));
}

function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
  return (0, _builder["default"]).apply(void 0, ["TSDeclareMethod"].concat(Array.prototype.slice.call(arguments)));
}

function tsQualifiedName(left, right) {
  return (0, _builder["default"]).apply(void 0, ["TSQualifiedName"].concat(Array.prototype.slice.call(arguments)));
}

function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSCallSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSConstructSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsPropertySignature(key, typeAnnotation, initializer) {
  return (0, _builder["default"]).apply(void 0, ["TSPropertySignature"].concat(Array.prototype.slice.call(arguments)));
}

function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSMethodSignature"].concat(Array.prototype.slice.call(arguments)));
}

function tsIndexSignature(parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSIndexSignature"].concat(Array.prototype.slice.call(arguments)));
}

function tsAnyKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSAnyKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsBooleanKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSBooleanKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsBigIntKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSBigIntKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsIntrinsicKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSIntrinsicKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsNeverKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSNeverKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsNullKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSNullKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsNumberKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSNumberKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsObjectKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSObjectKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsStringKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSStringKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsSymbolKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSSymbolKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsUndefinedKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSUndefinedKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsUnknownKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSUnknownKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsVoidKeyword() {
  return (0, _builder["default"]).apply(void 0, ["TSVoidKeyword"].concat(Array.prototype.slice.call(arguments)));
}

function tsThisType() {
  return (0, _builder["default"]).apply(void 0, ["TSThisType"].concat(Array.prototype.slice.call(arguments)));
}

function tsFunctionType(typeParameters, parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSFunctionType"].concat(Array.prototype.slice.call(arguments)));
}

function tsConstructorType(typeParameters, parameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSConstructorType"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeReference(typeName, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeReference"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypePredicate(parameterName, typeAnnotation, asserts) {
  return (0, _builder["default"]).apply(void 0, ["TSTypePredicate"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeQuery(exprName) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeQuery"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeLiteral(members) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeLiteral"].concat(Array.prototype.slice.call(arguments)));
}

function tsArrayType(elementType) {
  return (0, _builder["default"]).apply(void 0, ["TSArrayType"].concat(Array.prototype.slice.call(arguments)));
}

function tsTupleType(elementTypes) {
  return (0, _builder["default"]).apply(void 0, ["TSTupleType"].concat(Array.prototype.slice.call(arguments)));
}

function tsOptionalType(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSOptionalType"].concat(Array.prototype.slice.call(arguments)));
}

function tsRestType(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSRestType"].concat(Array.prototype.slice.call(arguments)));
}

function tsNamedTupleMember(label, elementType, optional) {
  return (0, _builder["default"]).apply(void 0, ["TSNamedTupleMember"].concat(Array.prototype.slice.call(arguments)));
}

function tsUnionType(types) {
  return (0, _builder["default"]).apply(void 0, ["TSUnionType"].concat(Array.prototype.slice.call(arguments)));
}

function tsIntersectionType(types) {
  return (0, _builder["default"]).apply(void 0, ["TSIntersectionType"].concat(Array.prototype.slice.call(arguments)));
}

function tsConditionalType(checkType, extendsType, trueType, falseType) {
  return (0, _builder["default"]).apply(void 0, ["TSConditionalType"].concat(Array.prototype.slice.call(arguments)));
}

function tsInferType(typeParameter) {
  return (0, _builder["default"]).apply(void 0, ["TSInferType"].concat(Array.prototype.slice.call(arguments)));
}

function tsParenthesizedType(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSParenthesizedType"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeOperator(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeOperator"].concat(Array.prototype.slice.call(arguments)));
}

function tsIndexedAccessType(objectType, indexType) {
  return (0, _builder["default"]).apply(void 0, ["TSIndexedAccessType"].concat(Array.prototype.slice.call(arguments)));
}

function tsMappedType(typeParameter, typeAnnotation, nameType) {
  return (0, _builder["default"]).apply(void 0, ["TSMappedType"].concat(Array.prototype.slice.call(arguments)));
}

function tsLiteralType(literal) {
  return (0, _builder["default"]).apply(void 0, ["TSLiteralType"].concat(Array.prototype.slice.call(arguments)));
}

function tsExpressionWithTypeArguments(expression, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["TSExpressionWithTypeArguments"].concat(Array.prototype.slice.call(arguments)));
}

function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
  return (0, _builder["default"]).apply(void 0, ["TSInterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsInterfaceBody(body) {
  return (0, _builder["default"]).apply(void 0, ["TSInterfaceBody"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeAliasDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsAsExpression(expression, typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSAsExpression"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeAssertion(typeAnnotation, expression) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeAssertion"].concat(Array.prototype.slice.call(arguments)));
}

function tsEnumDeclaration(id, members) {
  return (0, _builder["default"]).apply(void 0, ["TSEnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsEnumMember(id, initializer) {
  return (0, _builder["default"]).apply(void 0, ["TSEnumMember"].concat(Array.prototype.slice.call(arguments)));
}

function tsModuleDeclaration(id, body) {
  return (0, _builder["default"]).apply(void 0, ["TSModuleDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsModuleBlock(body) {
  return (0, _builder["default"]).apply(void 0, ["TSModuleBlock"].concat(Array.prototype.slice.call(arguments)));
}

function tsImportType(argument, qualifier, typeParameters) {
  return (0, _builder["default"]).apply(void 0, ["TSImportType"].concat(Array.prototype.slice.call(arguments)));
}

function tsImportEqualsDeclaration(id, moduleReference) {
  return (0, _builder["default"]).apply(void 0, ["TSImportEqualsDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsExternalModuleReference(expression) {
  return (0, _builder["default"]).apply(void 0, ["TSExternalModuleReference"].concat(Array.prototype.slice.call(arguments)));
}

function tsNonNullExpression(expression) {
  return (0, _builder["default"]).apply(void 0, ["TSNonNullExpression"].concat(Array.prototype.slice.call(arguments)));
}

function tsExportAssignment(expression) {
  return (0, _builder["default"]).apply(void 0, ["TSExportAssignment"].concat(Array.prototype.slice.call(arguments)));
}

function tsNamespaceExportDeclaration(id) {
  return (0, _builder["default"]).apply(void 0, ["TSNamespaceExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeAnnotation(typeAnnotation) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeParameterInstantiation(params) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeParameterDeclaration(params) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
}

function tsTypeParameter(constraint, _default, name) {
  return (0, _builder["default"]).apply(void 0, ["TSTypeParameter"].concat(Array.prototype.slice.call(arguments)));
}

function NumberLiteral() {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _builder["default"]).apply(void 0, ["NumberLiteral"].concat(args));
}

function RegexLiteral() {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return (0, _builder["default"]).apply(void 0, ["RegexLiteral"].concat(args));
}

function RestProperty() {
  console.trace("The node type RestProperty has been renamed to RestElement");

  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return (0, _builder["default"]).apply(void 0, ["RestProperty"].concat(args));
}

function SpreadProperty() {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");

  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return (0, _builder["default"]).apply(void 0, ["SpreadProperty"].concat(args));
}