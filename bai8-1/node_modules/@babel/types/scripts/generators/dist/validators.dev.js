"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = generateValidators;

var _index = _interopRequireDefault(require("../../lib/definitions/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var has = Function.call.bind(Object.prototype.hasOwnProperty);

function joinComparisons(leftArr, right) {
  return leftArr.map(JSON.stringify).join(" === ".concat(right, " || ")) + " === ".concat(right);
}

function addIsHelper(type, aliasKeys, deprecated) {
  var targetType = JSON.stringify(type);
  var aliasSource = "";

  if (aliasKeys) {
    aliasSource = joinComparisons(aliasKeys, "nodeType");
  }

  var placeholderSource = "";
  var placeholderTypes = [];

  if (_index["default"].PLACEHOLDERS.includes(type) && has(_index["default"].FLIPPED_ALIAS_KEYS, type)) {
    placeholderTypes.push(type);
  }

  if (has(_index["default"].PLACEHOLDERS_FLIPPED_ALIAS, type)) {
    placeholderTypes.push.apply(placeholderTypes, _toConsumableArray(_index["default"].PLACEHOLDERS_FLIPPED_ALIAS[type]));
  }

  if (placeholderTypes.length > 0) {
    placeholderSource = ' || nodeType === "Placeholder" && (' + joinComparisons(placeholderTypes, "(node as t.Placeholder).expectedNode") + ")";
  }

  var result = _index["default"].NODE_FIELDS[type] || _index["default"].FLIPPED_ALIAS_KEYS[type] ? "node is t.".concat(type) : "boolean";
  return "export function is".concat(type, "(node: object | null | undefined, opts?: object | null): ").concat(result, " {\n    ").concat(deprecated || "", "\n    if (!node) return false;\n\n    const nodeType = (node as t.Node).type;\n    if (").concat(aliasSource ? aliasSource : "nodeType === ".concat(targetType)).concat(placeholderSource, ") {\n      if (typeof opts === \"undefined\") {\n        return true;\n      } else {\n        return shallowEqual(node, opts);\n      }\n    }\n\n    return false;\n  }\n  ");
}

function generateValidators() {
  var output = "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport shallowEqual from \"../../utils/shallowEqual\";\nimport type * as t from \"../..\";\n\n";
  Object.keys(_index["default"].VISITOR_KEYS).forEach(function (type) {
    output += addIsHelper(type);
  });
  Object.keys(_index["default"].FLIPPED_ALIAS_KEYS).forEach(function (type) {
    output += addIsHelper(type, _index["default"].FLIPPED_ALIAS_KEYS[type]);
  });
  Object.keys(_index["default"].DEPRECATED_KEYS).forEach(function (type) {
    var newType = _index["default"].DEPRECATED_KEYS[type];
    var deprecated = "console.trace(\"The node type ".concat(type, " has been renamed to ").concat(newType, "\");");
    output += addIsHelper(type, null, deprecated);
  });
  return output;
}