"use strict";

var _util = _interopRequireDefault(require("util"));

var _stringifyValidator = _interopRequireDefault(require("../utils/stringifyValidator.js"));

var _toFunctionName = _interopRequireDefault(require("../utils/toFunctionName.js"));

var _index = _interopRequireDefault(require("../../lib/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var readme = ["# @babel/types\n\n> This module contains methods for building ASTs manually and for checking the types of AST nodes.\n\n## Install\n\n```sh\nnpm install --save-dev @babel/types\n```\n\n## API"];
var customTypes = {
  ClassMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  },
  Identifier: {
    name: "`string`"
  },
  MemberExpression: {
    property: "if computed then `Expression` else `Identifier`"
  },
  ObjectMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  },
  ObjectProperty: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  }
};
Object.keys(_index["default"].BUILDER_KEYS).sort().forEach(function (key) {
  readme.push("### " + key[0].toLowerCase() + key.substr(1));
  readme.push("```javascript");
  readme.push("t." + (0, _toFunctionName["default"])(key) + "(" + _index["default"].BUILDER_KEYS[key].join(", ") + ")");
  readme.push("```");
  readme.push("");
  readme.push("See also `t.is" + key + "(node, opts)` and `t.assert" + key + "(node, opts)`.");
  readme.push("");

  if (_index["default"].ALIAS_KEYS[key] && _index["default"].ALIAS_KEYS[key].length) {
    readme.push("Aliases: " + _index["default"].ALIAS_KEYS[key].map(function (key) {
      return "`" + key + "`";
    }).join(", "));
    readme.push("");
  }

  Object.keys(_index["default"].NODE_FIELDS[key]).sort(function (fieldA, fieldB) {
    var indexA = _index["default"].BUILDER_KEYS[key].indexOf(fieldA);

    var indexB = _index["default"].BUILDER_KEYS[key].indexOf(fieldB);

    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  }).forEach(function (field) {
    var defaultValue = _index["default"].NODE_FIELDS[key][field]["default"];
    var fieldDescription = ["`" + field + "`"];
    var validator = _index["default"].NODE_FIELDS[key][field].validate;

    if (customTypes[key] && customTypes[key][field]) {
      fieldDescription.push(": ".concat(customTypes[key][field]));
    } else if (validator) {
      try {
        fieldDescription.push(": `" + (0, _stringifyValidator["default"])(validator, "") + "`");
      } catch (ex) {
        if (ex.code === "UNEXPECTED_VALIDATOR_TYPE") {
          console.log("Unrecognised validator type for " + key + "." + field);
          console.dir(ex.validator, {
            depth: 10,
            colors: true
          });
        }
      }
    }

    if (defaultValue !== null || _index["default"].NODE_FIELDS[key][field].optional) {
      fieldDescription.push(" (default: `" + _util["default"].inspect(defaultValue) + "`");

      if (_index["default"].BUILDER_KEYS[key].indexOf(field) < 0) {
        fieldDescription.push(", excluded from builder function");
      }

      fieldDescription.push(")");
    } else {
      fieldDescription.push(" (required)");
    }

    readme.push(" - " + fieldDescription.join(""));
  });
  readme.push("");
  readme.push("---");
  readme.push("");
});
process.stdout.write(readme.join("\n"));