"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = generateAstTypes;

var _index = _interopRequireDefault(require("../../lib/index.js"));

var _stringifyValidator = _interopRequireDefault(require("../utils/stringifyValidator.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function generateAstTypes() {
  var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/ast-types.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  leadingComments: ReadonlyArray<Comment> | null;\n  innerComments: ReadonlyArray<Comment> | null;\n  trailingComments: ReadonlyArray<Comment> | null;\n  start: number | null;\n  end: number | null;\n  loc: SourceLocation | null;\n  type: Node[\"type\"];\n  extra?: Record<string, unknown>;\n}\n\nexport type CommentTypeShorthand = \"leading\" | \"inner\" | \"trailing\";\n\nexport type Node = ".concat(_index["default"].TYPES.sort().join(" | "), ";\n\n");
  var deprecatedAlias = {};

  for (var type in _index["default"].DEPRECATED_KEYS) {
    deprecatedAlias[_index["default"].DEPRECATED_KEYS[type]] = type;
  }

  var _loop = function _loop(_type) {
    var fields = _index["default"].NODE_FIELDS[_type];
    var fieldNames = sortFieldNames(Object.keys(_index["default"].NODE_FIELDS[_type]), _type);
    var struct = [];
    fieldNames.forEach(function (fieldName) {
      var field = fields[fieldName]; // Future / annoying TODO:
      // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:
      // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,
      // - declare an alias type for valid keys, detect the case and reuse it here,
      // - declare a disjoint union with, for example, ObjectPropertyBase,
      //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty
      //   as "ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)"

      var typeAnnotation = (0, _stringifyValidator["default"])(field.validate, "");

      if (isNullable(field) && !hasDefault(field)) {
        typeAnnotation += " | null";
      }

      var alphaNumeric = /^\w+$/;
      var optional = field.optional ? "?" : "";

      if (_index["default"].isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {
        struct.push("".concat(fieldName).concat(optional, ": ").concat(typeAnnotation, ";"));
      } else {
        struct.push("\"".concat(fieldName, "\"").concat(optional, ": ").concat(typeAnnotation, ";"));
      }
    });
    code += "export interface ".concat(_type, " extends BaseNode {\n  type: \"").concat(_type, "\";\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n");

    if (deprecatedAlias[_type]) {
      code += "/**\n * @deprecated Use `".concat(_type, "`\n */\nexport interface ").concat(deprecatedAlias[_type], " extends BaseNode {\n  type: \"").concat(deprecatedAlias[_type], "\";\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n\n");
    }
  };

  for (var _type in _index["default"].NODE_FIELDS) {
    _loop(_type);
  }

  for (var _type2 in _index["default"].FLIPPED_ALIAS_KEYS) {
    var types = _index["default"].FLIPPED_ALIAS_KEYS[_type2];
    code += "export type ".concat(_type2, " = ").concat(types.map(function (type) {
      return "".concat(type);
    }).join(" | "), ";\n");
  }

  code += "\n";
  code += "export interface Aliases {\n";

  for (var _type3 in _index["default"].FLIPPED_ALIAS_KEYS) {
    code += "  ".concat(_type3, ": ").concat(_type3, ";\n");
  }

  code += "}\n\n";
  return code;
}

function hasDefault(field) {
  return field["default"] != null;
}

function isNullable(field) {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields, type) {
  return fields.sort(function (fieldA, fieldB) {
    var indexA = _index["default"].BUILDER_KEYS[type].indexOf(fieldA);

    var indexB = _index["default"].BUILDER_KEYS[type].indexOf(fieldB);

    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}