"use strict";

var _index = _interopRequireDefault(require("../../lib/index.js"));

var _stringifyValidator = _interopRequireDefault(require("../utils/stringifyValidator.js"));

var _toFunctionName = _interopRequireDefault(require("../utils/toFunctionName.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var NODE_PREFIX = "BabelNode";
var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class ".concat(NODE_PREFIX, "Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: ").concat(NODE_PREFIX, "SourceLocation;\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentBlock extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentLine extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class ").concat(NODE_PREFIX, " {\n  leadingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  innerComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  trailingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?").concat(NODE_PREFIX, "SourceLocation;\n  extra?: { [string]: mixed };\n}\n\n"); //

var lines = [];

var _loop = function _loop(type) {
  var fields = _index["default"].NODE_FIELDS[type];
  var struct = ['type: "' + type + '";'];
  var args = [];
  var builderNames = _index["default"].BUILDER_KEYS[type];
  Object.keys(_index["default"].NODE_FIELDS[type]).sort(function (fieldA, fieldB) {
    var indexA = _index["default"].BUILDER_KEYS[type].indexOf(fieldA);

    var indexB = _index["default"].BUILDER_KEYS[type].indexOf(fieldB);

    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  }).forEach(function (fieldName) {
    var field = fields[fieldName];
    var suffix = "";
    if (field.optional || field["default"] != null) suffix += "?";
    var typeAnnotation = "any";
    var validate = field.validate;

    if (validate) {
      typeAnnotation = (0, _stringifyValidator["default"])(validate, NODE_PREFIX);
    }

    if (typeAnnotation) {
      suffix += ": " + typeAnnotation;
    }

    if (builderNames.includes(fieldName)) {
      args.push(_index["default"].toBindingIdentifierName(fieldName) + suffix);
    }

    if (_index["default"].isValidIdentifier(fieldName)) {
      struct.push(fieldName + suffix + ";");
    }
  });
  code += "declare class ".concat(NODE_PREFIX).concat(type, " extends ").concat(NODE_PREFIX, " {\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n"); // Flow chokes on super() and import() :/

  if (type !== "Super" && type !== "Import") {
    lines.push("declare export function ".concat((0, _toFunctionName["default"])(type), "(").concat(args.join(", "), "): ").concat(NODE_PREFIX).concat(type, ";"));
  } else {
    var functionName = (0, _toFunctionName["default"])(type);
    lines.push("declare function _".concat(functionName, "(").concat(args.join(", "), "): ").concat(NODE_PREFIX).concat(type, ";"), "declare export { _".concat(functionName, " as ").concat(functionName, " }"));
  }
};

for (var type in _index["default"].NODE_FIELDS) {
  _loop(type);
}

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _index["default"].TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var typeName = _step.value;
    var isDeprecated = !!_index["default"].DEPRECATED_KEYS[typeName];
    var realName = isDeprecated ? _index["default"].DEPRECATED_KEYS[typeName] : typeName;
    var decl = "declare export function is".concat(typeName, "(node: ?Object, opts?: ?Object): boolean");

    if (_index["default"].NODE_FIELDS[realName]) {
      decl += " %checks (node instanceof ".concat(NODE_PREFIX).concat(realName, ")");
    }

    lines.push(decl);
    lines.push("declare export function assert".concat(typeName, "(node: ?Object, opts?: ?Object): void"));
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
      _iterator["return"]();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

lines.push("declare export var VISITOR_KEYS: { [type: string]: string[] }", // assert/
"declare export function assertNode(obj: any): void", // builders/
// eslint-disable-next-line max-len
"declare export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): ".concat(NODE_PREFIX, "TypeAnnotation"), // eslint-disable-next-line max-len
"declare export function createUnionTypeAnnotation(types: Array<".concat(NODE_PREFIX, "FlowType>): ").concat(NODE_PREFIX, "UnionTypeAnnotation"), // eslint-disable-next-line max-len
"declare export function createFlowUnionType(types: Array<".concat(NODE_PREFIX, "FlowType>): ").concat(NODE_PREFIX, "UnionTypeAnnotation"), // this smells like "internal API"
// eslint-disable-next-line max-len
"declare export function buildChildren(node: { children: Array<".concat(NODE_PREFIX, "JSXText | ").concat(NODE_PREFIX, "JSXExpressionContainer | ").concat(NODE_PREFIX, "JSXSpreadChild | ").concat(NODE_PREFIX, "JSXElement | ").concat(NODE_PREFIX, "JSXFragment | ").concat(NODE_PREFIX, "JSXEmptyExpression> }): Array<").concat(NODE_PREFIX, "JSXText | ").concat(NODE_PREFIX, "JSXExpressionContainer | ").concat(NODE_PREFIX, "JSXSpreadChild | ").concat(NODE_PREFIX, "JSXElement | ").concat(NODE_PREFIX, "JSXFragment>"), // clone/
"declare export function clone<T>(n: T): T;", "declare export function cloneDeep<T>(n: T): T;", "declare export function cloneDeepWithoutLoc<T>(n: T): T;", "declare export function cloneNode<T>(n: T, deep?: boolean, withoutLoc?: boolean): T;", "declare export function cloneWithoutLoc<T>(n: T): T;", // comments/
"declare type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'", // eslint-disable-next-line max-len
"declare export function addComment<T: BabelNode>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T", // eslint-disable-next-line max-len
"declare export function addComments<T: BabelNode>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T", "declare export function inheritInnerComments(node: BabelNode, parent: BabelNode): void", "declare export function inheritLeadingComments(node: BabelNode, parent: BabelNode): void", "declare export function inheritsComments<T: BabelNode>(node: T, parent: BabelNode): void", "declare export function inheritTrailingComments(node: BabelNode, parent: BabelNode): void", "declare export function removeComments<T: BabelNode>(node: T): T", // converters/
"declare export function ensureBlock(node: ".concat(NODE_PREFIX, ", key: string): ").concat(NODE_PREFIX, "BlockStatement"), "declare export function toBindingIdentifierName(name?: ?string): string", // eslint-disable-next-line max-len
"declare export function toBlock(node: ".concat(NODE_PREFIX, "Statement | ").concat(NODE_PREFIX, "Expression, parent?: ").concat(NODE_PREFIX, "Function | null): ").concat(NODE_PREFIX, "BlockStatement"), // eslint-disable-next-line max-len
"declare export function toComputedKey(node: ".concat(NODE_PREFIX, "Method | ").concat(NODE_PREFIX, "Property, key?: ").concat(NODE_PREFIX, "Expression | ").concat(NODE_PREFIX, "Identifier): ").concat(NODE_PREFIX, "Expression"), // eslint-disable-next-line max-len
"declare export function toExpression(node: ".concat(NODE_PREFIX, "ExpressionStatement | ").concat(NODE_PREFIX, "Expression | ").concat(NODE_PREFIX, "Class | ").concat(NODE_PREFIX, "Function): ").concat(NODE_PREFIX, "Expression"), "declare export function toIdentifier(name?: ?string): string", // eslint-disable-next-line max-len
"declare export function toKeyAlias(node: ".concat(NODE_PREFIX, "Method | ").concat(NODE_PREFIX, "Property, key?: ").concat(NODE_PREFIX, "): string"), // toSequenceExpression relies on types that aren't declared in flow
// eslint-disable-next-line max-len
"declare export function toStatement(node: ".concat(NODE_PREFIX, "Statement | ").concat(NODE_PREFIX, "Class | ").concat(NODE_PREFIX, "Function | ").concat(NODE_PREFIX, "AssignmentExpression, ignore?: boolean): ").concat(NODE_PREFIX, "Statement | void"), "declare export function valueToNode(value: any): ".concat(NODE_PREFIX, "Expression"), // modifications/
// eslint-disable-next-line max-len
"declare export function removeTypeDuplicates(types: Array<".concat(NODE_PREFIX, "FlowType>): Array<").concat(NODE_PREFIX, "FlowType>"), // eslint-disable-next-line max-len
"declare export function appendToMemberExpression(member: ".concat(NODE_PREFIX, "MemberExpression, append: ").concat(NODE_PREFIX, ", computed?: boolean): ").concat(NODE_PREFIX, "MemberExpression"), // eslint-disable-next-line max-len
"declare export function inherits<T: BabelNode>(child: T, parent: ".concat(NODE_PREFIX, " | null | void): T"), // eslint-disable-next-line max-len
"declare export function prependToMemberExpression(member: ".concat(NODE_PREFIX, "MemberExpression, prepend: ").concat(NODE_PREFIX, "Expression): ").concat(NODE_PREFIX, "MemberExpression"), "declare export function removeProperties<T>(n: T, opts: ?{}): void;", "declare export function removePropertiesDeep<T>(n: T, opts: ?{}): T;", // retrievers/
// eslint-disable-next-line max-len
"declare export var getBindingIdentifiers: {\n    (node: ".concat(NODE_PREFIX, ", duplicates?: boolean, outerOnly?: boolean): { [key: string]: ").concat(NODE_PREFIX, "Identifier | Array<").concat(NODE_PREFIX, "Identifier> },\n    keys: { [type: string]: string[] }\n  }"), // eslint-disable-next-line max-len
"declare export function getOuterBindingIdentifiers(node: BabelNode, duplicates?: boolean): { [key: string]: ".concat(NODE_PREFIX, "Identifier | Array<").concat(NODE_PREFIX, "Identifier> }"), // traverse/
"declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };".replace(/(^|\n) {2}/g, "$1"), // eslint-disable-next-line
"declare export function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;", "declare export function traverseFast<T>(n: BabelNode, h: TraversalHandler<T>, state?: T): void;", // utils/
// cleanJSXElementLiteralChild is not exported
// inherit is not exported
"declare export function shallowEqual(actual: Object, expected: Object): boolean", // validators/
// eslint-disable-next-line max-len
"declare export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (?BabelNode) => boolean", "declare export function is(type: string, n: BabelNode, opts: Object): boolean;", "declare export function isBinding(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean", "declare export function isBlockScoped(node: BabelNode): boolean", "declare export function isImmutable(node: BabelNode): boolean", "declare export function isLet(node: BabelNode): boolean", "declare export function isNode(node: ?Object): boolean", "declare export function isNodesEquivalent(a: any, b: any): boolean", "declare export function isPlaceholderType(placeholderType: string, targetType: string): boolean", "declare export function isReferenced(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean", "declare export function isScope(node: BabelNode, parent: BabelNode): boolean", "declare export function isSpecifierDefault(specifier: BabelNodeModuleSpecifier): boolean", "declare export function isType(nodetype: ?string, targetType: string): boolean", "declare export function isValidES3Identifier(name: string): boolean", "declare export function isValidES3Identifier(name: string): boolean", "declare export function isValidIdentifier(name: string): boolean", "declare export function isVar(node: BabelNode): boolean", // eslint-disable-next-line max-len
"declare export function matchesPattern(node: ?BabelNode, match: string | Array<string>, allowPartial?: boolean): boolean", "declare export function validate(n: BabelNode, key: string, value: mixed): void;");

for (var _type in _index["default"].FLIPPED_ALIAS_KEYS) {
  var types = _index["default"].FLIPPED_ALIAS_KEYS[_type];
  code += "type ".concat(NODE_PREFIX).concat(_type, " = ").concat(types.map(function (type) {
    return "".concat(NODE_PREFIX).concat(type);
  }).join(" | "), ";\n");
}

code += "\ndeclare module \"@babel/types\" {\n  ".concat(lines.join("\n").replace(/\n/g, "\n  ").trim(), "\n}\n"); //

process.stdout.write(code);